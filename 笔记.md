# 50.实现 pow(*x*, *n*)，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。

## 1.暴力（原创）：

**暴力（时间超限），核心思路就是for循环n次，每次都乘个x**，最后返回的时候考虑负数幂次的情况。

~~~js
var myPow = function(x, n) {
    if(n === 0) return 1;
    let x_origin = x;
    //通过Math.abs获取n的绝对值
    let absoluteN = Math.abs(n);
    for(let i = 1;i < absoluteN; i++ ) {
        x = x * x_origin;
    }
    return n > 0 ? x : 1 / x;
};
~~~

时间复杂度：`O(n)`

空间复杂度：`0(1)`

## 2.分治法（快速幂）（题解）：

~~~js
var myPow = function(x, n) {
    if(n === 1) return x;
    if(n === 0) return 1;
    if(n < 0) {
        x = 1/x;
        n = Math.abs(n);
    }
    //n为偶数
    if(n % 2 === 0) {
        return myPow(x*x, n/2);
    } else {
        return x*myPow(x*x, Math.floor(n/2));
    }
};
~~~

时间复杂度：`0(logn)`，一个数的n次幂每次函数体执行都变成另一个数的n/2次幂，哪个数的幂这个数多大不重要，因为我们函数结束条件是n决定的，n足够小，函数才结束。所以经过logn次函数体执行，n就变成1了，也就是标志递归结束。然后每次函数体的执行，也就是这个规模缩小的过程，所花费的时间是单位1，执行logn次，所以时间复杂度就是`O(logn)`

空间复杂度：`0(logn)`：递归栈的深度。

方法收集：

* `Math.abs(n)`：获取n的绝对值
* `Math.pow(n,m)`：获取n的m次幂