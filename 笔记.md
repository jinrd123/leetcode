# 11.盛水最多的容器

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 （height[1] && height[8]）
```

## 1.双指针法

核心思想就是：

如果我们选择了两个index组成墙之后，如果把两个index向中间靠，有三种情况：

* 比较矮的那个index向中间靠：盛的水可能会增加（index移动之后比另一个index位置高）
* 比较高的index向中间靠：盛的水一定会减少

所以我们用left和right分别指向height数组的两头，每次只让比较矮的指针向中间靠，遍历一遍height来不断更新可能的最大值，最后返回

~~~js
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    let left = 0;
    let right = height.length - 1;
    let ans = 0;
    let currentContent;
    while(left < right) {
        /*
        	计算当前的容量并更新ans
        */
        currentContent = Math.min(height[left], height[right]) * (right - left);
        ans = currentContent > ans ? currentContent : ans;
        if(height[left] === height[right]) {
            /*
            	如果两个位置一样高，那么两个index的内部还有可能出现更高的两个墙，但是这两个index不可能了，直接都向中间靠就行
            */
            left += 1;
            right -= 1;
        }else if(height[left] < height[right]) {
            left += 1;
        }else if(height[left] > height[right]) {
            right -= 1;
        }
    }
    return ans;
};
~~~

## 2.双重for循环计算所有情况



# 15.三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

~~~javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
	
  	// 针对某个很长的全零特例
    if(nums.every((item) => item === 0)) return [[0, 0, 0]];

    let result = [];
    let left;
    let right;
    let sum;
    nums = nums.sort((a, b) => a - b);
    for(let i = 0; i < nums.length; i ++) {
        left = i + 1;
        right = nums.length - 1;
        while(left < right) {
            sum = nums[i] + nums[left] + nums[right];
            if(sum === 0) {
                result.push([nums[i], nums[left], nums[right]]);
                left ++;
                right --;
            } else if(sum > 0) {
                right --;
            } else if(sum < 0) {
                left ++;
            } 
        }
    }
  	// ------ 三元组数组如何根据元组内容去重 —— 利用Set，但是转Set前进行stringify ------
    result = Array.from(new Set(result.map(JSON.stringify))).map(JSON.parse);
    return result;
};
~~~

在往`result`数组中放三元组时来者不拒，只要和等于0都放进来了，到后面再去重

核心思想可以理解为：给一个数组nums，**通过一次遍历，**找出所有和为xxx的两个数（所有满足条件的两元组集合）

1. 把nums进行排序，由小到大
2. 定义两个指针分别指向最左和最右，看两个指针位置的数之和与目标值的大小关系，比目标值小，左指针右移；比目标值大，右指针左移

**如何理解这两个指针的移动：**这两个指针指向的数为我们手头最大和最小的两个数，如果和小于目标，针对左指针的值来说，给他我们手头上最大的值都比目标小，所以左指针处的值加上一个数永远不可能得到目标，所以要放弃左指针。

三数之和基于上面两数之和的思想，我们先确定一个数，即最外层一个`for`，然后循环体内执行`while`寻找两数之和的逻辑即可

优化思路：在把找到的答案加入`result`数组之前进行判断是否重复，这样就不用最后去重。需要明确的是，查找两数之和的算法逻辑是能查找全部可能的（可能重复但不会遗漏），所以针对外层`for`的一个`i`，如果当前`i`与上一个相同，那么可以直接跳过当前`i`。

# 16.最接近的三数之和

遍历思路完全一样，外层`for`，内层双指针。**双指针遍历，如果要找两数之和等于几，一定能找出所有满足的两数；在这里，寻找最接近某值的两数，遍历一次，遍历过程中记录过程值，一定能找到最值**

这里解释一下15，16题为什么选择外层`for`，内层双指针，而且左指针等于`i + 1`是正确的，因为双指针法寻找的目标是唯一的：两数之和等于某个值，指针的移动全部基于靠近这个目标。举个例子，下标为`3, 6, 7`为要找的最有优解，也就是说`i = 3`，如果`i`等于4时，还考虑`i`之前的元素，那么如果找到的最优解中包含`i`之前的元素`x`，那么一定在`i`等于`x`时就已经发现了这组解。所以左指针等于`i + 1`即可，是不会遗漏最优解的。

~~~js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
    let result;
    let right;
    let left;
    let minimumDiffAbs = Infinity;
    nums = nums.sort((a, b) => a - b);
    for(let i = 0; i < nums.length; i ++) {
        let twoSum = target - nums[i];
        left = i + 1;
        right = nums.length - 1;
        while(left < right) {
            let diffAbs = Math.abs(twoSum - nums[left] - nums[right]);
            if(diffAbs < minimumDiffAbs) {
                minimumDiffAbs = diffAbs;
                result = nums[i] + nums[left] + nums[right];
            }
            if(nums[left] + nums[right] < twoSum) {
                left ++;
            }else if(nums[left] + nums[right] > twoSum) {
                right --;
            } else {
                return nums[i] + nums[left] + nums[right];
            }  
        }
    }
    return result;
};
~~~



# 19.删除链表倒数第n个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

## 链表定位——快慢指针法

~~~js
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  	// 首先创建一个链表结点指向head，快慢指针同时指向这个结点，至于为什么创建这个头，其实是倒推而来的：我们想利用指针的距离差来定位链表，那么快指针停下来的标志就是next为null，随便举个例子，链表长度为3，删除倒数第三个，那么快指针停下来时（指向最后一个结点），满指针应该指向head的前一个结点——这样方便删除第一个结点，所以推断得知：初始时快慢指针都指向head的前一个合适
    let newHead = new ListNode(0, head),
        slow = fast = newHead;
    for(let i = 0;i < n; i ++) {
        fast = fast.next;
    }
    while (fast.next !== null) {
        fast = fast.next; 
        slow = slow.next
    };
    slow.next = slow.next.next;
    return newHead.next;
};
~~~



# 20.有效的括号（栈与队列）

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

**遍历整个字符串，遇到左括号入栈，遇到右括号`pop`栈顶元素，检查是否为对应的左括号，相当于所有的右括号是检查当前字符串是否出现了括号混乱的情况，但是此时检查还不完全，因为左括号可能比较多，比如`((()`，这样单纯依靠右括号检查不出来，所以最后判断栈是否为空，为空则说明既通过了右括号匹配检查，而且左右括号相等，是有效的括号。**

~~~js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    const stack = [];
    for(let i = 0; i < s.length; i ++) {
        switch(s[i]) {
            case "(":
            case "[":
            case "{":
                stack.push(s[i]);
                break;
            case ")":
                if(stack.pop() !== '(') {
                    return false;
                }
                break;
            case "]":
                if(stack.pop() !== '[') {
                    return false;
                }
                break;
            case "}":
                if(stack.pop() !== '{') {
                    return false;
                }
                break;
        }
    }
    if(stack.length === 0) {
        return true;
    }
    return false
};
~~~



# 22.括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

## 1.回溯法（递归➕剪枝）

~~~js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
    let result = [];
  	// 递归（回溯）算法
  	// 有效括号 <===> 从左至右遍历括号字符串，累计左括号与右括号的数量，始终保持leftNum >= rightNum
    function backtracking(result, leftNum, rightNum, str) {
        if(str.length == 2*n) { // 括号数量累计完成，即找到一种有效括号
            result.push(str);
            return;
        } 
        // 剪枝
        if(leftNum < rightNum) { // 已经是无效括号了，往后也不用再累积了
            return;
        }
        if(leftNum >= rightNum) { // 当前还是有效括号
            if(leftNum === n) { // 有效括号，自然左括号是比右括号多的，所以只判断左括号到没到n即可，如果到了n，说明左括号的数量用完了
                backtracking(result, leftNum, rightNum + 1, str + ")");
            } else {
                backtracking(result, leftNum + 1, rightNum, str + "(");
                backtracking(result, leftNum, rightNum + 1, str + ")");
            }
        }
    }
    backtracking(result, 0, 0, "");
    return result;
};
~~~



# 32.给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

2022.11.29字节实习一面  困难题，感觉技巧性偏多

示例：

```
输入：s = "((())"
输出：4
解释：最长有效括号子串是 "(())"
```

示例：

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

通过上面的示例可知：所谓有效括号，并不一定是一个整体，比如`((()))`这种，而是`()()`这种并列型的括号也算是有效括号，所以我们遍历找子有效括号的时候，不能用`)`的序号减去`(`的序号得到有效括号的长度，因为这样对于并列型括号是不对的，我们应该用`)`的序号减去**有效区间起点**，这里的区间就是指子有序括号，比如`")()())"`的中间的`()()`就是一个有效区间。

上面我们明确了题目的意思之后，难点就在于如何来记录这个区间了。

首先对于这种括号匹配的题目，毋庸置疑使用一个数组当作栈，然后用栈方法`pop`和`push`来进行操作。

首先确定核心逻辑：拿`)`的序号减去栈顶（区间起点）得到有效括号的长度，所以如何设计才能**让栈顶始终为区间起点**就是解决的关键。

* 因为要让栈顶为区间起点，所以我们设计了让`(`无脑进栈的情况下，遇见`)`就得让栈顶出栈，这样就可以把结合成功的括号排出栈外，保证栈顶序号为区间起点

* 初始化栈顶为`-1`，这样对于正常情况下的括号整体`(())`和并列括号`()()`，能满足`)`的序号减去`-1`就是区间长度
* 对于`)))`这种情况，我们应该修改区间起点，因为对于`)`我们的第一部逻辑就是`stack.pop();`，这样会导致栈空，所以判断，如果栈空，我们就让此时正在处理的`)`的序号入栈去做区间起点
* 对于`(((`这种情况，我们没必要刻意去处理，因为我们设计的逻辑就是栈顶为区间起点。对于`(`我们无脑入栈，我们取区间起点始终是在栈顶取，所以不影响

这里我的代码实现是：

~~~js
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
    let maxLength = 0;
    let temp = 0;
    let stack = [];
    stack.push(-1);
    for(let i = 0;i < s.length; i ++) {
        if(s[i] == "(") {
            stack.push(i);
        }else {
            stack.pop();
            if(stack.length === 0) {
                stack.push(i);
            }
            /*
            	每次遇见`)`时会更新temp，更新temp时就判断是否超过了全局最大值
            */
            temp = i - stack[stack.length - 1];
            if(temp > maxLength) {
                maxLength = temp;
            }
        }
    }
    return maxLength;
};
~~~

说不上来学到了什么，感觉只学会了这个题目的这一种方法，这种方法设计能力需要锻炼



# 39.组合总和（回溯）

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

**示例 2：**

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```
输入: candidates = [2], target = 1
输出: []
```



首先本题找所有组合，关键词**组合**——暴力搜索，考虑回溯法

## 回溯法模版

~~~
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
~~~

**回溯法剪枝切入点：针对`for`循环，要么减少for循环的循环次数，要么在`for`循环内根据新的递归参数，决定要不要进行这次递归**

一般来说，存放结果存放的一般就是`path`，即我们遍历过程中产生的东西，相当于`map(当前遍历的数组)`，我感觉这种声明一个全局变量`path`的操作针对js语言来说，没必要，其他语言需要这样的原因是不方便声明一个数组，而我们js写个`[]`就是一个新数组，结合拓展运算符也非常方便进行扩充。但是这样声明全局`path`自然也有好处，节省空间，而且在我们`for`循环递归调用回溯算法之前进行回溯函数参数的计算，可以更灵活的进行剪枝（决定要不要进行递归调用）

标准回溯：

~~~js
var combinationSum = function (candidates, target) {
    let res = [];
    let path = [];
    candidates.sort((a, b) => a - b); //这个是为了后面剪枝


    const bt = (sum, startIndex) => {
        if (sum > target) return;
        if (sum === target) {
            res.push(path.slice());
            return;
        }
        for (let i = startIndex; i < candidates.length  && sum + candidates[i] <= target; i++) {
            let cur = candidates[i];
            if (sum + cur > target) break; //剪枝
            sum += cur;
            path.push(cur);
            bt(sum, i);
            path.pop();
            sum -= cur;
        }
    }

    bt(0, 0);
    return res;
};
~~~

简写回溯（但这里的简写不是说无剪枝，是指**`for`循环递归调用回溯函数之前不进行参数的计算，直接在函数调用中完成计算，并且回溯函数执行完毕之后，因为参数都是独立的拷贝，所以也无需进行参数（全局变量）还原**）：

如下代码具体针对题目，进行注释：

~~~javascript
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {

    let result = [];
    
  	// 回溯函数的参数不着急写，直接写函数体，用到什么参数到回到这里补
  	// 关于startIndex参数，即for循环的遍历起始变量，这是针对题目本身**组合**的特点加入的变量，因为我们寻找的所有组合，组合是无序的，所以前面i = 0 到i = startIndex遍历的时候已经把所有包含0到startIndex的结果加入到结果集合中了——因为回溯本身就是暴力搜索，不会遗漏的搜索每种可能，举个例子：for(let i = 0...) { 递归调用 }，当i等于0时，就把包含candidates[0]的可能结果都找全了，i等于1时，调用递归函数就没必要考虑i=0的情况了
    const backTrace = (startIndex, currentSum, currentArr) => {
      	// 确定回溯的退出条件，本题都是正数求和，所以一旦求和大于target，就可以退出了；如果求和等于target，就放入结果集再退出
      	// 并且这里我们知道了应该补充一个参数currentSum来记录当前的求和
        if(currentSum === target) {
            result.push(currentArr);
            return;
        } else if(currentSum > target) {
            return;
        }
				
      	// 处理好一层的搜索逻辑即可
        for(let i = startIndex; i < candidates.length; i ++) {
          	// startIndex为i，更新currentSum，更新currentArr，进行递归调用
            backTrace(i, currentSum + candidates[i], [...currentArr, candidates[i]]);
        }
    }

    backTrace(0, 0, []);

    return result;
};
~~~

进行剪枝，参考如上标准回溯：先对`candidates`数组进行排序，对`for`循环的条件加强限制：`for (let i = startIndex; i < candidates.length  && sum + candidates[i] <= target; i++)`，即减少搜索树的一整个树枝（防止树的宽度增长）；进入递归调用前增加限制：`if (sum + cur > target) break;`，即不让搜索树这个树枝的深度增长。



# 42.接雨水

![image-20221130000119647](./image/42接雨水.png)

解法核心就是遍历整个数组，累计横向上每个位置接的雨水量

每一个柱子接的水 = min（左边最高的柱子， 右边最高的柱子） - 当前柱子的高度—简单理解就是木桶效应，这个柱子存多少水取决于两侧最矮的柱子多高

这个柱子能积水的前提是左边和右边都有比这个柱子高的柱子

按照上面的逻辑：

~~~js
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let sum = 0;
    for(let i = 0;i < height.length;i ++) {
        /*
        	left 和 right 为布尔型变量，意思是判断height数组中左边和右边有没有比height[i]大的数
        	这里先用slice切割数组，然后用find方法判断数组中是否存在满足某种条件的数据
        */
        let left = height.slice(0, i).find((value) => value > height[i]);
        let right = height.slice(i+1, height.length).find((value) => value > height[i]);
        if(left && right) {
            /*
            	Math.max搭配数组的拓展运算符实现寻找数组的最大值
            */
            sum += Math.min(Math.max(...height.slice(0, i)), Math.max(...height.slice(i+1, height.length))) - height[i];
        }
    }
    return sum;
};
~~~

优化思路：每个位置不去判断是否两侧有比当前位置高的柱子，而是都按照积水公式进行计算，如果两侧任意一侧没有比当前位置的高的柱子，那么这个位置的积水量的计算值为负数，所以求和时省略负数即可。



# 49.字母异位词分组

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**示例 2:**

```
输入: strs = [""]
输出: [[""]]
```

**示例 3:**

```
输入: strs = ["a"]
输出: [["a"]]
```

解决思路，同一组异位单词，将他们用`sort`函数排序后得到同一个字符串，所以我们遍历一遍`strs`数组，然后用一个`Map`记录排序字符串与对应的异位单词数组即可，最后再`for of`遍历一遍`Map`构造答案数组即可。

~~~js
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
    const map = new Map();
    for(let i = 0;i < strs.length; i ++) {
        let orderedStr = strs[i].split("").sort((a, b) => a > b ? -1 : 1).join("");
        if(map.has(orderedStr)) {
            map.get(orderedStr).push(strs[i]);
        } else {
            map.set(orderedStr, [strs[i]]);
        }
    }
    const result = [];
    for(let value of map.values()) {
        result.push(value);
    }
    return result;
};
~~~



# 50.实现 pow(*x*, *n*)，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。

## 1.暴力（原创）：

**暴力（时间超限），核心思路就是for循环n次，每次都乘个x**，最后返回的时候考虑负数幂次的情况。

~~~js
var myPow = function(x, n) {
    if(n === 0) return 1;
    let x_origin = x;
    //通过Math.abs获取n的绝对值
    let absoluteN = Math.abs(n);
    for(let i = 1;i < absoluteN; i++ ) {
        x = x * x_origin;
    }
    return n > 0 ? x : 1 / x;
};
~~~

时间复杂度：`O(n)`

空间复杂度：`0(1)`

## 2.分治法（快速幂）（题解）：

~~~js
var myPow = function(x, n) {
    if(n === 1) return x;
    if(n === 0) return 1;
    if(n < 0) {
        x = 1/x;
        n = Math.abs(n);
    }
    //n为偶数
    if(n % 2 === 0) {
        return myPow(x*x, n/2);
    } else {
        return x*myPow(x*x, Math.floor(n/2));
    }
};
~~~

时间复杂度：`0(logn)`，一个数的n次幂每次函数体执行都变成另一个数的n/2次幂，哪个数的幂这个数多大不重要，因为我们函数结束条件是n决定的，n足够小，函数才结束。所以经过logn次函数体执行，n就变成1了，也就是标志递归结束。然后每次函数体的执行，也就是这个规模缩小的过程，所花费的时间是单位1，执行logn次，所以时间复杂度就是`O(logn)`

空间复杂度：`0(logn)`：递归栈的深度。

方法收集：

* `Math.abs(n)`：获取n的绝对值
* `Math.pow(n,m)`：获取n的m次幂



# 51.N皇后（回溯）

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

## 思路

主函数`solveNQueens`思路就是回溯法，根据皇后的攻击规则容易得知一行只放一个，所以`n * n`的棋盘放`n`个皇后问题转化为每行放一个皇后，皇后应该放在哪一列，**主函数思路看注释，两个辅助函数最重要的就是要时刻弄清楚row和col是对应实际意义的行和列还是对应的真实坐标，这个只要清晰就可以，辅助函数row和col确定清楚，函数体内就问题不大，然后主函数中传参时也注意转化即可。**

~~~js
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
    let result = [];

    const backTrace = (currentRow, aPosition) => {
      	// currentRow代表现在放了几行了，如果放了n行了，表示找到答案
        if(currentRow === n) {
            result.push(aPosition);
            return;
        }
				
      	// 处理一层的搜索逻辑
      	// i代表下一行的第i列
        for(let i = 0;i < n; i ++) {
          	// isPeace函数判断下一行放在第（i + 1）列会不会冲突，不冲突返回true
            if(isPeace(aPosition, i + 1, n)) {
              	// 更新aPosition（一种位置），createRow即创建题目要求的'...Q'类型的行
                let newPosition = [...aPosition, createRow(i + 1, n)];
              	// 递归调用
                backTrace(currentRow + 1, newPosition)
            }
        }
    }
		
    // 执行
    backTrace(0, []);
		
  	// 返回
    return result;
};

// 列col和行row都按照从一开始的实际意义
const isPeace = (currentQueenPosition, col, n) => {
    let row = currentQueenPosition.length + 1;
    // 往左上进行验证
    // 按照实际意义坐标先左上平移
    let rowTemp = row - 1;
    let colTemp = col - 1;
    // 下面 - 1 为转真实坐标
    while(colTemp - 1 >= 0 && rowTemp - 1 >= 0) {
        if(currentQueenPosition[rowTemp - 1][colTemp - 1] === "Q") {
            console.log("@@@");
            return false;
        }
        rowTemp --;
        colTemp --;
    }
    // 往右上验证
    // 先按照实际意义进行右上平移
    rowTemp = row - 1;
    colTemp = col + 1;
    // - 1为转真实坐标
    while(colTemp - 1 <= n && rowTemp - 1 >= 0) {
        if(currentQueenPosition[rowTemp - 1][colTemp - 1] === "Q") {
            return false;
        }
        rowTemp --;
        colTemp ++;
    }
    // 往上验证
    // 先按照实际意义向上平移
    rowTemp = row - 1;
    // colTemp 为真实坐标
    colTemp = col - 1;
    while(rowTemp - 1 >= 0) {
        if(currentQueenPosition[rowTemp - 1][colTemp] === "Q") {
            return false;
        }
        rowTemp --;
    }
    return true;
}

const createRow = (col, n) => {
    let row = '';
    for(let i = 0;i < n;i ++) {
        if(i === col - 1) {
            row += "Q";
        }else {
            row += ".";
        }
    }
    return row;
}
~~~



# 53.给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

## 1.核心思想其实与动态相似（原创）：

从头到尾遍历一遍nums，不断更新最大和

我们需要借助一个beforeSum来记录当前指针位置之前连续项的和。

贪心思想：指针新遍历一个值的时候，**有可能更新最大和**的情况有两种：

* beforeSum大于零，所以我们把当前项加上beforeSum
* beforeSum小于零，当前项自身

这个beforeSum是帮助当前项“冲击“最大和的，所以如果曾经的beforeSum小于零，那么指针新考察过一个项之后，就把beforeSum换成这个刚考察的项即可；如果beforeSum大于零，它就对于”冲击“最大和有帮助，所以我们要保留它并累加上当前项。

~~~js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let currentMax = nums[0];
    let beforeSum = nums[0];
    for(let i = 1;i < nums.length;i ++) {
        if(beforeSum<0) {
            //beforeSum小于零，可能产生的最大和：nums[i]
            if(nums[i] > currentMax) {
                currentMax = nums[i];
            }
            beforeSum = nums[i];
        }else {
            //beforeSum大于零，可以产生的最大和：beforeSum+nums[i]
            beforeSum += nums[i];
            if(beforeSum > currentMax) {
                currentMax = beforeSum;
            }
        }
    }
    return currentMax;
};
~~~

* 时间复杂度：我们只遍历了一次数组，所以`0(n)`

* 空间复杂度：我们只借助了两个变量，使用了常数空间，所以`O(1)`

## 2.动态规划

定义子问题：以`nums`数组中第`i`项结尾的子数组的最大和记为`f(i)`

**`f(i) = max{(f(i-1)+nums[i]), nums[i]}`**

所以遍历nums数组时，就用`nums[i]`表示`f(i)`：如果nums[i-1] > 0，那么f(i) = nums[i] = nums[i-1] + nums[i]

~~~js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let currentMax = nums[0];
    for(let i = 1;i < nums.length;i ++ ) {
        currentMax = Math.max((nums[i] + nums[i - 1]), nums[i], currentMax);
        if(nums[i-1] > 0) {
            nums[i] += nums[i - 1];
        }
    }
    return currentMax;
};
~~~

我感觉和方法一思想完全相同，只是说我们直接利用了nums数组本身来记录方法一中的beforeSum。

时空复杂度也是`O(n)`和`O(1)`

# 54.给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

## 1.模拟法

题目要的数组就是我们由外到内转圈的遍历matrix出来的，那么我们就进行遍历：

### 两个技巧：

* 构造标记（标记是否遍历过某位置）数组时，构造的标记数组`matrixCopy`比原数组大一圈，好处就是遍历`matrix`的时候，如果不大一圈，我们在走最外圈的时候走完一条边的判断条件就是数组不越界，而到了内圈标记数组才能发挥作用：判断条件根据标记数组得知有没有走过。但是我们如果标记数组构造的大一圈，就可以**从头到尾统一判断条件：根据标记数组看是否走过。**（注意标记数组和对应原数组位置坐标有一个单位的偏移即可）

* 第二个技巧：while循环的结束条件怎么写：

  * 首先模拟走圈的时候，最外层有一个while循环，内层有四个while循环，对应一圈的四个边，不管是外层的while还是内层的while，写代码的时候我都并没有直接写出来while的结束条件，而都是`while(true)`，回头看来，这个操作属实可圈可点。

  * 先说最外层的while，从结构来看，while的退出是内部满足了一定条件之后`break`，从逻辑来看，之后遍历完一条边，转换到下一条边的时候，如果没位置（matrixCopy为false）,就说明整个遍历完成。不管四个方向向哪走的时候，都有可能满足最外层的退出条件，所以总结：`while(true)`的结构内`break`可以让while退出的逻辑变得简单（不用高度凝练的写在while后面的括号里）

  * 内层的while退出，并不和外层一样很多种退出的场景，内层的while就是完成一定的任务：走完一条边。所以内层这里`while(true)`的目的和上面不同。内层while的结束条件就是下一个位置没发走了（`matrixCopy[x][y]`为`false`），while内部肯定是每次都沿着遍历的方向让坐标变化一个单位，但是这里我们不盲目每次都加一，因为如果每次都稳定加一，然后while内部判断条件是`matrixCopy[x][y]`为`true`，就会造成最后一下坐标变化之后虽然坐标不满足while的条件了，while推出了，但是相当于多加了一下，往后坐标也不能用了，就好比for循环，每次i++，然后最后一次不满足条件了，此时i就已经“走远了"。所以我们在while内部进行退出判断：先预先判断一下坐标移动之后的状态，然后再移动：

    ~~~js
    while(true) {
    	...
        //预先判断移动之后的状态是否合理再移动
        if(matrixCopy[x-1][y]) {
            x -= 1;
        }else {
            break;
        }
    }
    ~~~

代码：

~~~js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
    let ans = [];
    let matrixCopy = new Array(matrix.length + 2);
    for(let i = 0;i < matrixCopy.length; i ++) {
        matrixCopy[i] = new Array(matrix[0].length + 2);
    }
    
    for(let i = 0;i < matrixCopy.length;i ++) {
        for(let j = 0;j < matrixCopy[0].length;j ++) {
            //初始化标记数组
            /*
            	根据边界条件特殊处理最外面一圈
            	最外面一圈设置为false，表示不能遍历
            */
            if((i == 0) || (i == matrixCopy.length-1) || (j == 0) || (j == matrixCopy[0].length-1)) {
                matrixCopy[i][j] = false;
            }else {
                matrixCopy[i][j] = true;
            }
        }
    }
    let x = 1;
    let y = 1;
    while(true) {

        //向右走
        //判定位置总结while中判定，就会导致状态已经错误了,或者说目前的状态修改不是盲目每轮都修改，而是只有保证状态修改后正确再修改
        while(true) {
            ans.push(matrix[x-1][y-1]);
            matrixCopy[x][y] = false;
            if(matrixCopy[x][y+1]) {
                y += 1;
            }else {
                break;
            }
        }
        //改变坐标位置为向下的起点
        if(matrixCopy[x+1][y]) {
            x = x+1;
        }else {//如果没法转弯了，那就是遍历完成了
            break;
        }

        //向下走
        while(true) {
            ans.push(matrix[x-1][y-1]);
            matrixCopy[x][y] = false;
            if(matrixCopy[x+1][y]) {
                x += 1;
            }else {
                break;
            }
        }
        if(matrixCopy[x][y-1]) {
            y = y-1;
        }else {
            break;
        }

        while(true) {
            ans.push(matrix[x-1][y-1]);
            matrixCopy[x][y] = false;
            if(matrixCopy[x][y-1]) {
                y -= 1;
            }else {
                break;
            }
        }
        if(matrixCopy[x-1][y]) {
            x = x-1;
        }else {
            break;
        }

        //向上走
        while(true) {
            ans.push(matrix[x-1][y-1]);
            matrixCopy[x][y] = false;
            if(matrixCopy[x-1][y]) {
                x -= 1;
            }else {
                break;
            }
        }
        if(matrixCopy[x][y+1]) {
            y = y+1;
        }else {
            break;
        }
    }
    return ans;
};
~~~

时空复杂度都是：`O(mn)`，都是两层循环

# 55.跳跃游戏

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

我觉着这个题最重要的就是悟到题目的核心：说白了，只要不被0卡住，就一定能到最后。

**如果被题目的标题（跳跃游戏）所误导，用模拟跳跃的方法去解题，那么事倍功半。**

## 1.贪心法—遍历更新

**对于每个位置，我们都跳最远，更新我们能到达的最远距离（贪心）**，遍历完之后，只需要比较我们能到达的最远距离是否够用即可。

~~~js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    let lengthMax = 0
    for(let i = 0; i < nums.length-1; i ++) {
        /*
        	更新lengthMax有个前提条件:
        		目前的我们能到达的位置lengthMath要大于位置i
        */
        if(lengthMax >= i && (i + nums[i]) > lengthMax) {
            lengthMax = i + nums[i];
        }
    }
    if(lengthMax >= (nums.length-1)) {
        return true;
    }
    return false;
};
~~~

时间复杂度：`O(n)`，遍历一次数组

空间复杂度：`O(1)`

# 56.合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

**示例 1：**

~~~
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
~~~

## 1.排序+遍历

首先先把intervals中的区间按照区间起点的升序排列目的是方便判断相邻区间是否有重叠，这样遍历intervals数组考察每一个区间，如果新考察的区间左边界小于结果集最后一个区间的右边界，说明存在重叠的可能，如果新考察的区间的右边界要大于结果集最后一个区间的右边界，即可更新结果集中的最后一个区间的右边界；如果没有重叠的可能，就直接把新考察的区间放进结果集。

~~~js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    let ans = [];
    //升序排序
    intervals.sort((a, b) => a[0] - b[0]);

    //循环开始前初始化:先放进去第一个元素，这样从第二考察区间开始就有比较的对象了
    ans.push(intervals[0]);

    for(let i = 1;i < intervals.length; i ++) {
        //如果新考察的区间的起点小于结果集最后一个区间的终点，那么有可能重叠（还需要比较新考察区间的终点是否大于结果集最后一个区间的终点）
        if(intervals[i][0] <= ans[ans.length-1][1]) {
            if(intervals[i][1] > ans[ans.length-1][1]) {//如果存在重叠，那么更新结果集的区间的终点即可
                ans[ans.length-1][1] = intervals[i][1];
            }
        }else {//两个区间没有交集，不存在重叠的可能
            ans.push(intervals[i]);
        }
    }
    return ans;
};
~~~

时间复杂度：`O(nlog n)`，其中 n 为区间的数量。排序`O(nlog n)`>构造答案`0(n)`

空间复杂度：`O(nlog n)`，其中 nn 为区间的数量。**这里计算的是存储答案之外，使用的额外空间**。`O(nlog n)` 即为排序所需要的空间复杂度。



# 62.不同路径（动态规划）

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

分析：

首先，美团2020前端校招做这个题的时候用的暴力dfs，没超时，但是感觉确实挺蠢的。为什么呢，为啥能直接确定这个可以动态规划呢，**对于每一个m，n，都是由上面或者左边移动而来的，所以这里明显符合dp的思想，即复杂问题的解由简单子问题的解进行简单计算而来。**构造m*n的二维dp数组，确定`dp[i][j]`的含义：即从左上角走到i行j列的路径数；递推公式：`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`；初始化dp数组：因为dp[i]依赖的是左边和上边的dp值，所以我们把第一行和第一列初始化，初始化的值都是1（到达第一行或者第一列的每一个点都只有一条路径）；确定遍历顺序：从左到右 && 从上到下。最后计算完dp数组返回`dp[m - 1][n - 1]`即可。

~~~js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    let dp = [];
    for(let i = 0; i < m; i ++) {
        dp.push(new Array(n));
    }
    for(let i = 0; i < n; i ++) {
        dp[0][i] = 1;
    }
    for(let i = 0; i < m; i ++) {
        dp[i][0] = 1;
    }
    for(let row = 1; row < m; row ++) {
        for(let col = 1; col < n; col ++) {
            dp[row][col] = dp[row][col - 1] + dp[row - 1][col];
        }
    }
    return dp[m - 1][n - 1];
};
~~~



# 63.有障碍的不同路径（动态规划）

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```



说白了这个和62唯一的区别就是**dp数组初始化时不能直接全初始化为1**以及**构造dp数组时障碍处为0**：

~~~js
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacleGrid) {
    let dp = [];
    const m = obstacleGrid.length;
    const n = obstacleGrid[0].length;
    for(let i = 0; i < m; i ++) {
        dp.push(new Array(n));
    }
    // 初始化第一行
    for(let i = 0; i < n; i ++) {
        dp[0][i] = 0;
    }
    for(let i = 0; (i < n) && (obstacleGrid[0][i] !== 1); i ++) {
        dp[0][i] = 1;
    }
    // 初始化第一列
    for(let i = 0; i < m; i ++) {
        dp[i][0] = 0;
    }
    for(let i = 0; i < m && (obstacleGrid[i][0] !== 1); i ++) {
        dp[i][0] = 1;
    }

    for(let row = 1; row < m; row ++) {
        for(let col = 1; col < n; col ++) {
            if(obstacleGrid[row][col] === 1) {
                dp[row][col] = 0;
            } else {
                dp[row][col] = dp[row][col - 1] + dp[row - 1][col];
            }
        }
    }
    for(let i = 0; i < m; i ++) {
        let str = '';
        for(let j = 0; j < n; j ++) {
            str += dp[i][j] + ' ';
        }
        console.log(str);
    }
    return dp[m - 1][n - 1];
};
~~~



# 70.爬楼梯（动态规划入门）

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

## 1.递归（时空复杂度因为重复计算严重超限）

~~~js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n === 0) {
        return 0;
    }
    if(n === 1) {
        return 1;
    }
    if(n === 2) {
        return 2;
    }
    return climbStairs(n - 1) + climbStairs(n - 2);
};
~~~

## 2.dp动态规划——>记录每个高度的跳法数量避免重复计算

dp[n]代表楼梯高度为n的跳法数量，初始化0，1，2高度后逐个向后计算即可（正向模拟，正向计算）

~~~js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    const dp = [0,1,2];
    for(let i = 3 ; i <=n ; i++){
        dp[i] = dp[i-1] + dp[i-2]; 
    }
    return dp[n];
};
~~~

复杂度：

- 时间复杂度: O(n)
- 空间复杂度: O(n)

## 3.优化2的空间复杂度

只用length为3的数组存储，dp[2]为高度为n的台阶的跳法（dp[0]为n-2高度的跳法、dp[1]为n-1高度的跳法）

~~~js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
    const dp = [0, 0, 1];
    for (let i = 1; i <= n; i++) {
        dp[0] = dp[1];
        dp[1] = dp[2];
        dp[2] = dp[0] + dp[1]
    }
    return dp[2];
};
~~~

## 动态规划全新理解

说白了就是一个斐波那契数列，可以看509题动态规划套路

下面具体分析一下代码

~~~js
/**
 * @param {number} n
 * @return {number}
 */
// 爬到n阶的楼梯上这个问题有多少种爬法，可以分解为爬到n-1阶和爬到n-2阶爬法数之和，即问题分解
var climbStairs = function (n) {
  	// 这里的三个return相当于处理一些边界情况，因为n=1、n=2，n值太小了，所以不满足动态规划分解问题的条件，我们直接返回
    if(n === 0) return 1; // 没有实际意义，为了契合判题标准罢了，即n=0，结果就是1
    if(n === 1) return 1; 
    if(n === 2) return 2;
  	// 对于n大于2的问题的解，由n-1和n-2两个子问题的解得到，所以我们的dp数组长度为2记录两个状态即可
    let step;
    const dp = [1, 2];
    for(let i = 2; i < n; i ++) { // i=2表示我们已经得到了n=2之前的问题的解，举例法确定i的限制：n=3，我们只需要计算一次即可，所以是i<n（而非i<=n）。
        step = dp[0] + dp[1];
        dp[0] = dp[1];
        dp[1] = step;
    }
    return step;
};
~~~



# 146.LRU缓存

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

 

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

## 完全Map模拟

* `Map.set`放入`Map`结构中的`(key, value)`其实是有顺序的，我们用`Map.keys().next().value`即可获取最早放入`Map`中的**键**（`Map.keys()`方法获取迭代器，`Map.keys().next()`迭代器的`next`方法获取一个具体的对象，包含`value`与`done`属性，`value`的值即为最早放入集合中的键值对的键）：

  ~~~js
  const map = new Map()
  
  map.set("xhr", 456); // Map(1) {'xhr' => 456}
  
  map.set("jrd", 123); // Map(2) {'xhr' => 456, 'jrd' => 123}
  
  map.keys() // MapIterator {'xhr', 'jrd'} —— 迭代器对象
  
  map.keys().next() // {value: 'xhr', done: false} —— 迭代器对象调用next方法获取具体的迭代器元素（一个迭代器元素就对应了一个map中的元素）
  ~~~

* 剩下的就是利用map去按照要求模拟即可：

  * `get`一个元素时先删了再重新放进去，这样相当于刷新了最近使用时间
  * `put`元素时朝map里普通放入就行了（题目要求放入一个重复的key时，更新value，这些都按要求来写就行）。主要是关于`capacity`的维护问题，`Map`也帮我们解决了——`Map.size`属性返回map的大小，所以不用我们维护动态的`capacity`，`capacity`初始化时存放一个静态容量即可，然后如果超出容量，直接`this.map.delete(this.map.keys().next().value);`删除第一个元素（最久未使用的元素）即可。

~~~js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.map = new Map();
    this.capacity = capacity;
};

LRUCache.prototype.get = function(key) {
    if(this.map.has(key)) {
        const value = this.map.get(key);
        this.map.delete(key);
        this.map.set(key, value);
        return value;
    }
    return -1;
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    if(this.map.has(key)) {
        this.map.delete(key);
    }
    this.map.set(key, value);
    if(this.map.size > this.capacity) {
        this.map.delete(this.map.keys().next().value);
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
~~~





# 200.岛屿的数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

## 1.沉岛法

我们遍历整个地图，如果遇见了`"1"`，我们就算遇见了一个岛屿，岛屿数量＋1，但是我们在继续遍历下一个位置之前，需要把与这个位置相连的陆地都变成`"0"`，也就是所谓的沉岛

~~~js
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
    let ans = 0;
    for(let i = 0;i < grid.length; i ++) {
        for(let j = 0;j < grid[0].length;j ++) {
            if(grid[i][j] === "1") {
                ans ++;
                turnZero(i, j, grid);
            }
        }
    }
    return ans;
};
function turnZero(x, y, grid) {
    if(x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] === '0') return;
    grid[x][y] = "0";
    turnZero(x - 1, y, grid);
    turnZero(x + 1, y, grid);
    turnZero(x, y - 1, grid);
    turnZero(x, y + 1, grid);
}
~~~

# 225.用队列实现栈（栈与队列）

~~~js
var MyStack = function() {
    this.queue = [];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    this.queue.push(x);
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    for(let i = 0; i < this.queue.length - 1; i ++) {
        this.queue.push(this.queue.shift());
    }
    return this.queue.shift();
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
    return this.queue[this.queue.length - 1];
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return this.queue.length === 0;
};

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
~~~

用一个队列即可模拟栈，栈与队列`push`的行为都一样，增加元素就`push`，但是出元素时，我们要用我们的队列的`shift`方法弹出队列的最后一个（队尾）元素，这就需要我们进行一个循环，把队头除了最后一个元素之外的所有元素都依次加入队尾即可。





# 232.用栈实现队列（栈与队列）

~~~js
var MyQueue = function() {
    this.inStack = [];
    this.outStack = [];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    while(this.outStack.length !== 0) {
        this.inStack.push(this.outStack.pop());
    }
    this.inStack.push(x);
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    while(this.inStack.length !== 0) {
        this.outStack.push(this.inStack.pop());
    }
    return this.outStack.pop();
};

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    while(this.inStack.length !== 0) {
        this.outStack.push(this.inStack.pop());
    }
    return this.outStack[this.outStack.length - 1];
};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return this.outStack.length === 0 && this.inStack.length === 0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
~~~

用两个栈模拟队列，只需要出队列的时候把入栈元素依次移动到出栈里，然后用出栈实现出队列；同理如队列用入栈实现，也需要把元素全移动到入栈中。



# 322 -> 279.完全平方数（动态规划、装满背包所需的最少物品数量）

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

题目给的`n`即为背包大小，我们的任务就是填满背包，用完全平方数填满，所以我们手动构造一个由完全平方数构成的物品集合`goods`（`[1, 4, 9, 16, ... ]`），然后问题就转化为了322。

注意构造`goods`数组时要尽可能小的构造，防止超限即可

~~~js
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
    // 我们构造的物品集合要在包含所有可能的前提下尽可能的小，不然会超限：一个数的完全平方不大于n即可，Math.ceil(n**(1/2)) <= n
    // new Array的数组fill之后才能map正确访问index
    const goods = new Array(Math.ceil(n**(1/2))).fill(0).map((item, index) => {
        return (index + 1)**2;
    });

    // 申请初始空间
    const dp = new Array(goods.length + 1);
    for(let i = 0; i < dp.length; i ++) {
        dp[i] = new Array(n + 1).fill(Infinity);
        // dp数组初始化
        dp[i][0] = 0;
    }
    

    for(let i = 1; i <= goods.length; i ++) {
        for(let j = 0; j <= n; j ++) {
            dp[i][j] = dp[i - 1][j];
            if(j >= goods[i - 1]) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - goods[i - 1]] + 1);
            }
        }
    }

    return dp[goods.length][n];
};
~~~



# 322.零钱兑换（动态规划、装满背包所需的最少物品数量）

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

定义`dp[i][j]`：前`i`个物品去装满容量为`j`的背包最少需要`dp[i][j]`种装法。

递推公式：**`dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - weight[i]] + 1)`**，理解的话还是把`dp[i][j]`的来源分两类，一类就是不涉及第`i`个物品，或者说多了第`i`种物品我不用，所以`dp[i - 1][j]`是转变为`dp[i][j]`的一种可能；然后就是使用了第`i`种物品，最直接转变到`dp[i][j]`的状态就是`dp[i][j - weight[i]] + 1`，表示我们最少用了一个第`i`种物品，在背包装了`j - weight[i]`的东西时再装一个第`i`种物品，所以再加1，就转换为`dp[i][j]`。

如果我们不用滚动数组进行空间压缩，申请二维数组空间的时候，千万不要这么写：

~~~js
const dp = new Array(coins.length + 1).fill(new Array(amount + 1).fill(0))
~~~

总之就是用`new Array`去填充数组的第二维，这样会使`dp[x]`都是同一个数组的引用。

正确的申请空间：

~~~js
const dp = new Array(coins.length + 1);
for(let i = 0; i <= coins.length; i ++) {
    dp[i] = new Array(amount + 1).fill(Infinity);
}
~~~

`dp`数组初始化：

根据递推公式发现`dp[i][j]`依赖的是左边和上面的`dp`值，所以我们至少要把第一行和第一列进行初始化，然后才能用递推公式进行计算。题目的示例3已经告诉我们`amount = 0`时`dp`值为0，即第一列为`0`，意思是我们要装满大小为`0`的背包，只需要`0`个物品，然后初始化第一行，第一行表示我们拥有的物品集合为前`0`个，所以我们想装满背包是不可能的，所以我们把第一行初始化为无穷大，因为`dp`值的推导依赖的是正上方和正左方的值，所以`dp[0][0]`是不会影响计算的，是`0`是`Inifinty`都无所谓。

然后进行`dp`推导计算就可以了：

~~~js
for(let i = 1; i <= coins.length; i ++) { // i代表当前的物品集合为前i个
  	// 因为我们要求的是两者中的较小值，所以我们这里j的for循环中不能进行j - coins[i - 1] >= 0的判断，这是为了保证dp[i][j] = dp[i - 1][j]; 的稳定执行，换句话说不能因为j - coins[i - 1] < 0，dp[i][j]就一直是Infinty，它的另一个来源是稳定可以访问的。
    for(let j = 0; j <= amount; j ++) { // j代表背包的容量
        dp[i][j] = dp[i - 1][j]; 
        if(j - coins[i - 1] >= 0) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - coins[i - 1]] + 1);
        }
    }
}
~~~

题解代码：

~~~js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    const dp = new Array(coins.length + 1);
    for(let i = 0; i <= coins.length; i ++) {
        dp[i] = new Array(amount + 1).fill(Infinity);
    }
    for(let i = 0; i <= coins.length; i ++) {
        dp[i][0] = 0;
    }
    
    for(let i = 1; i <= coins.length; i ++) {
        for(let j = 0; j <= amount; j ++) {
            dp[i][j] = dp[i - 1][j];
            if(j - coins[i - 1] >= 0) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - coins[i - 1]] + 1);
            }
        }
    }
    if(dp[coins.length][amount] == Infinity) {
        return -1;
    }
    return dp[coins.length][amount]
};
~~~





# 343.整数拆分（动态规划）

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```



**重点在于递推公式**

~~~js
/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function(n) {
  	// 确定dp数组的含义：dp[i]即为拆分i能得到的最大乘积
    const dp = [];
  	// dp数组初始化，dp[2]为1（必须拆分为2个以上的数，所以dp[0]、dp[1]也没必要理会，不是题目考察的范围）
    dp[2] = 1;
    for(let i = 3; i <= n; i ++) { // 第一层循环i表示计算dp[i]
        dp[i] = 0;
      	// j代表从i中拆出来的一个数，拆分dp[i]的可能有三种：
      	// 1.拆分为j和i-j即为最大
      	// 2.没拆出来最大解，但是当前拆分出来j的选择是正确的
      	// 3.dp[i]已经是最大了
        for(let j = 1; j < i - 1; j ++) { // 遍历j，不断更新dp[i]
            dp[i] = Math.max(dp[i], j * (i - j), j * dp[i - j]);
        }
    }
    return dp[n];
};
~~~



# 518 -> 377.组合总和 Ⅳ

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**

```
输入：nums = [9], target = 3
输出：0
```

**说白了就是求完全背包之装满背包的排列数**，由518的分析直接秒杀：

~~~js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var combinationSum4 = function(nums, target) {
    const dp = new Array(target + 1).fill(0);
    dp[0] = 1;
    for(let j = 0; j <= target; j ++) {
        for(let i = 0; i < nums.length; i ++) {
            if(j - nums[i] >= 0) {
                dp[j] += dp[j - nums[i]];
            }
        }
    }
    return dp[dp.length - 1];
};
~~~





# 416.分割等和子集（动态规划、0-1背包变式、滚动数组）

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

**题目分析**

这个题目给了一个`nums`数组，能不能分割成两个等和的子集，说白了就是从数组中挑元素能不能挑出满意的集合，所谓满意，就是挑出`nums`数组总和的一半。这种精确挑出一个目标的问题，我们可以转化为背包问题：我们定义一个背包，容量为`nums`数组总和的一半，`nums`数组中的每个数字都看成物品，其体积和价值都是其值本身，0-1背包的递推公式意义还是不变，就是`dp[i][j]`的含义还是代表前`i`个物品，体积`j`的背包能装的最大价值，但是针对这个问题本身，我们背包容量为`nums`数组总和的一半而且物品体积和价值相同，我们就计算他能装的最大价值，考察每一个`i`对应`j=nums总和一半`时`dp`数组的值，如果`dp[i][target](这里target代表背包容量) === target(target代表物品价值)`，就说明原问题数组可以分成等和子集。

~~~js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
  	// 计算target，并且数组总和如果不能整除2，就不可能被一堆整数分成等和的两部分
    let target = nums.reduce((previous, current)=> {
        return previous + current;
    }, 0);
    if((target % 2) === 0) {
        target = target / 2;
    } else {
        return false;
    }
  
  	// 这里我们使用滚动数组优化（一维dp数组）
    let dp = new Array(target + 1).fill(0); // 坑点：背包问题中根据背包容积申请数组大小时数组长度一定是容积加1，因为（容积为0）和（容积等于容积）都是背包数组的大小范围
    for(let i = 0; i < nums.length; i ++) {
        for(let j = target; j - nums[i] >= 0; j --) { // 滚动数组需要倒序计算
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
        }
      	// 对于每一个i，即每一种物品组合，都要考虑背包容量为target时是不是能装target价值
        if(dp[target] === target) {
            return true;
        }
    }
    return false;
};
~~~



# 494.目标和（0-1背包变式、动态规划、装满背包有多少种组合、详细分析）

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```
输入：nums = [1], target = 1
输出：1
```

 

问题分析：

其实就是我们给`nums`数组中的数决定正负，然后判断符合标准的有多少种可能。假设`nums`数组中所有数的和为`sum`，然后我们计算一下正数的和（也就是我们想要装满的背包的大小，即`bagValueSize`）：`bagValueSize - (sum - bagValueSize) = target`（正数减去负数等于`target`），这样我们就计算出了`bagValueSize`，问题转换为**我们恰好装满`bagValueSize`大小的背包有多少种装法，自然nums数组中的每一项都是物品，其价值与体积相同。**

定义`dp`数组的含义：（用前`i`件物品）`dp[j]`即代表装满容量为`j`的背包有`dp[j]`种装法

递推公式：`dp[j] = ∑(i = 0 -> i = nums.length - 1)dp[j - nums[i]]`，举个例子理解一下，求`dp[5]`即求（用`nums`数组中的物品）装满容量为5的背包有多种装法。如果我们有重量（价值）为`1`的物品，要想装满容量为5的背包，基于这个物品就相当于要装满容量为4的背包即可，同理如果我们有重量为3的物品，基于这个物品要想装满容量为5的背包就相当于要装满容量为2的背包。所以针对`nums`数组中的每一个数，都可以给`dp[j]`提供一些“组成”，但是我们又不能直接计算出来`dp[j]`，因为其实这里隐藏了一个信息是`dp[j]`是针对`i = nums.length - 1`，即物品要包含所有的物品，所以我们要外层`i`遍历物品数量，对于这个`i`正确的理解就是给所有的`dp[j]`都加上一个数，这个数就是针对`nums[i]`这个物品给`dp[j]`提供的装满背包的方法数，直到算到最后一个`i`，这时候内层遍历`j`时计算出来的每一个`dp[j]`才是正确的、最终的`dp[j]`，因为这时候`dp[j] += dp[j - nums[i]]; `加上这个`dp[j - nums[i]]`才算是把最后一个物品所提供的可能加进`dp[j]`去。

然后`dp[j]`所依赖的是`j`比较小的`dp`值，为了保证计算`dp[j]`时用到数据的正确性，所以我们内层`for`倒序遍历。

所以`dp`数组的计算过程在代码中的实现如下：

~~~js
for(let i = 0; i < nums.length; i ++) {
    for(let j = bagValueSize; j - nums[i] >= 0; j --) {
        dp[j] += dp[j - nums[i]];
    }
}
~~~

但是我们需要初始化一开始的`dp[0]`，究竟是`0`还是啥，这个不能凭感觉的，举个具体的简单的例子，然后看看真实场景下`dp[0]`初始化为多少正确就初始化为多少。

举个例子，第一个物品即`nums[0]`为1，然后我们第一层`for`的`i = 0`，即计算物品集合为只有第一个物品的`dp[j]`，然后我们计算`dp[1]`，也就是我们的背包容量为1，按照我们的递推公式`dp[1] += (dp[1 - nums[0]] = dp[0])`，因为我们知道`dp[1]`等于1，只有放进去第一个物品这个唯一的可能，所以推导得知，（为了符合递推公式的计算逻辑）我们应该把`dp[0]`初始化为`1`。

最终题解代码：

~~~js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findTargetSumWays = function(nums, target) {
    const bagValueSize = (target + nums.reduce((previous, current) => {
        return previous + current;
    }, 0)) / 2
    if(bagValueSize % 1 !== 0) return 0;
    if(bagValueSize < 0) return 0;
    const dp = new Array(bagValueSize + 1).fill(0);
  
  	// dp数组初始化
    dp[0] = 1;
  	
  	// 计算dp数组
    for(let i = 0; i < nums.length; i ++) {
        for(let j = bagValueSize; j - nums[i] >= 0; j --) {
            dp[j] += dp[j - nums[i]];
        }
    }
  
    return dp[dp.length - 1];
};
~~~





# 504.进制转换——七进制数

给定一个整数 `num`，将其转化为 **7 进制**，并以字符串形式输出。

~~~js
/**
 * @param {number} num
 * @return {string}
 */
var convertToBase7 = function(num) {
    if(num === 0) return "0";
    /*
    	我们的核心逻辑只处理num为正数的情况，所以我们先记录一下正负，如果是负数最后加个"-"
    */
    let isNegative = num < 0 ? true : false;
    num = Math.abs(num);
    /*
    	核心逻辑：ans字符串的逐位构造
    */
    let ans = '';
    while(num > 0) {
        /*
        	模7直接得到最低为
        */
        let last = num % 7;
        ans = last + ans; // 构造ans
        /*
        	num更新：减去最低位然后除7
        */
        num -= last;
        num /= 7;
    }
    return isNegative ? ('-' + ans) : ans;
};
~~~

# 509.斐波那契数（动态规划入门）

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

## 动态规划

动态规划（dynamic programming动态编程），即原问题可以分解成更简单的子问题，通过解决简单子问题最终得到目标问题的解

### 五部曲

1. 定义dp数组的含义：动态规划，我们需要借助一个dp数组来描述问题的含义，可能是一维数组或者二维数组，比如斐波纳切问题中`dp`数组的含义：`dp[i]`就表示第i个斐波纳切数为`dp[i]`

2. 递推公式：`dp[i] = dp[i - 1] + dp[i - 2]`，对于斐波那契数列递推公式已经告诉我们了，也就是说计算`dp[i]`的问题可以被分解为计算`dp[i - 1]`和`dp[i - 2]`两个子问题。

3. `dp`数组如何初始化：对于斐波那契数列，初始化也告诉我们了，即`dp[0] = 1 & dp[1] = 1`

4. 遍历顺序：求斐波那契数列问题时，遍历顺序也很显然，因为第`i`个斐波那契数由第`i-1`和`i-2`个数得到，所以自然是从前往后遍历

5. 打印dp数组：对于动态规划问题`debug`的方式。

6. 或许可以压缩dp数组：比如斐波那契数列问题中只需要两个数组位置➕一个`sum`即可存储状态：

   ~~~js
   let sum = dp[1] + dp[0];
   dp[0] = dp[1];
   dp[1] = dp[2];
   dp[2] = sum;
   ~~~

代码：

~~~js
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    const dp = [0, 1];
    if(n === 0) return 0;
    if(n === 1) return 1;
    let sum;
    for(let i = 1; i < n; i ++) { // i = 1表示当前已经知道dp[1]了，只需要算出来dp[n]即可，根据举例法(n = 2时，需要计算一次即可)得知 i < n。
        sum = dp[1] + dp[0];
        dp[0] = dp[1];
        dp[1] = sum;
    }
    return sum;
};
~~~



# 494 -> 518.零钱兑换 II

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**示例 2：**

```
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

**示例 3：**

```
输入：amount = 10, coins = [10] 
输出：1
```

这个题目更直白，思路完全与494转换后的背包问题一样，但唯一不同的是，这里**每个物品可以用无数次**

我们在494目标和中举例中说过，针对每一个`nums[i]`（物品），都构成了`dp[j]`的值的一部分，也就是`dp[j - nums[i]]`，494因为每个物品只有一个，所以这样针对第`i`件物品，它所提供的解的一部分就全了；但是这里每个物品可以用无限次，所以说要考虑基于这个物品有1件、有两件、有3件...的情况，每一种情况都是`dp[j]`的一部分。

**但是这里要明确一点——dp数组的含义，这里`dp[j]`同494，还是表示的每个物品都是一个独立的个体的情况下对于背包容量j能装满的方式，而并没有切换到完全背包的思路上来。**

~~~js
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */
var change = function(amount, coins) {
    const dp = new Array(amount + 1).fill(0);
    dp[0] = 1;
    for(let i = 0; i < coins.length; i ++) { // 第一层for还是遍历物品种类
        let j = amount;
        while(j - coins[i] >= 0) { // 第二层同样还是循环遍历背包容量
            let k = 1;
            while((j - k * coins[i]) >= 0) { // 这里完全背包相较于494——0-1背包装满问题，增加一层for循环，考虑同一类物品选的各种个数
                dp[j] += dp[j - k * coins[i]];
                k ++;
            }
            j --;
        }
    }
    return dp[dp.length - 1];
};
~~~

## 完全背包

`dp[i][j]`表示前`i`种硬币中凑出金额为`j`的硬币组合数/方案数。

递推公式：

~~~js
dp[i][j] = dp[i - 1][j] + dp[i][j - weight[i]]
~~~

这个递推公式就是单纯的字面意思，`dp[i][j]`就是完全由两部分组成，理解：考虑`dp[i][j]`的来源组成，我们要考虑的是如果才能全面（表达式全面覆盖`dp[i][j]`）且简单（表达式尽可能少）的表达清楚`dp[i][j]`的来源：我们把来源分成两大类，分别是：1.物品集合里不存在第`i`个元素 2.物品集合里存在第`i`个元素。首先这一定是一个覆盖全面的“全集”，然后针对第1类，因为不包含第`i`个物品，dp第一维肯定是`i - 1`（不能是`i - 2`...，那样就包含不全面了），dp第二维限制背包的容积，那肯定也是`j`，所以第1类所给`dp[i][j]`提供的组成就是`dp[i - 1][j]`；然后考虑第2类，我们需要保证这个组成包含了第`i`个物品，我们直接解释一下`dp[i][j - weight[i]]`吧，首先dp第一维为`i`，没啥好说的，表示我们物品集合为前`i`个物品，至于dp第二维为什么是`j - weight[i]`，可能会有疑问，这不是表示了只放了一个第`i`件物品吗，是不是没表示全面呢，其实这就陷入误区了，这里这个`weight[i]`表示的是最后一个加入背包中的第`i`类物品，不管前面的`j - weight[i]`中有几个第`i`种物品，这不需要关心了，只要是最后一个，也就是`j - weight[i]`加入这一个后变成`j`的这一个是第`i`种物品，就足够了。不像0-1背包装满背包的问题中，需要西格玛求和对于每一个物品提供的可能（即对于物品1，物品2，物品3，`dp[j] = dp[j - weight[0]] + dp[j - weight[1]] + dp[j - weight[2]]`）。

**我觉着上面总结的还是不清晰，只是大概表示了一种意思，这里最终解释一下`dp[i][j]`的递推公式的组成，即分成两类：有第i种物品和没有第i中物品两类，从这两类里找`dp[i][j]`的直接来源，我们要装满容量为`j`背包，自然没有第`i`种物品，加上第`i`种物品之前肯定是`dp[i - 1][j]`，这里一定不要陷入去理解`dp`如何来的这个误区，我们假设出来dp数组的含义之后，它怎么来的就不要管了，这不也正是动态规划的秒处吗！！，至于有第`i`种物品，直接转化到`dp[i][j]`的就是`dp[i][j - weight[i]]`，这里的直接转换说白了就是指与`dp[i][j]`的值一样（在前`i`件物品集合条件下）**

（真不行就记住吧...）

然后如果用滚动数组进行空间压缩的话，递推公式：

~~~
dp[j] = dp[j] + dp[j - weight[i]]
~~~

**但它的实际所表示的完整递推含义就是上面的二维的，计算`dp[i][j]`时所依赖的是上面和左边的数据，所以最内层的for循环需要正序遍历以保证使用数据的正确性。**

多说一句，这里完全背包的装满问题的递推公式，其实和0-1背包的装满问题就完全不一样了，这个就是意义很清晰的二维数组的转化，和0-1背包装最大价值是完全类似的。换句话说，0-1背包的装满问题，它的dp数组并不能用二维数组去描述，没有正确的意义，它的i只是一种迭代计算，对每一个背包容量去遍历累加所有物品提供的可能。

题解：

滚动数组的本质还是二维数组的状态转换，`dp[0] = 1`也是举例法得知的符合递推公式的一个初始值。

~~~js
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */
var change = function(amount, coins) {
    const dp = new Array(amount + 1).fill(0);
    dp[0] = 1;
    for(let i = 0; i < coins.length; i ++) {
        for(let j = coins[i]; j <= amount; j ++) {
            dp[j] = dp[j] + dp[j - coins[i]];
        }
    }
    return dp[dp.length - 1];
};
~~~



## 组合数 or 排列数

先遍历物品种类，内层再便利背包容量这样求的是组合数：

~~~js
for(let i = 0; i < coins.length; i ++) {
    for(let j = coins[i]; j <= amount; j ++) {
        dp[j] = dp[j] + dp[j - coins[i]];
    }
}
~~~

先遍历背包容量，再遍历物品种类（写法上单纯交换两个for循环顺序，其他代码原封不动）这样求的是排列数：

~~~js
for(let j = coins[i]; j <= amount; j ++) {
  	for(let i = 0; i < coins.length; i ++) {
        dp[j] = dp[j] + dp[j - coins[i]];
    }
}

// 意思就是上面的意思，但是上面的写法会报错，因为第一层for循环里访问不到i，所以
// 1. j从0开始遍历
// 2. 把保证j - coins[i] >= 0的逻辑放在最里面
for(let j = 0; j <= target; j ++) {
    for(let i = 0; i < nums.length; i ++) {
        if(j - nums[i] >= 0) {
            dp[j] += dp[j - nums[i]];
        }
    }
}
~~~

我并不是很理解透彻里面的奥妙，也花了不少时间去尽力给自己一个理解了，暂时用别人的评论来帮助记忆吧：

* 第一种：先遍历物品，再遍历背包，背包盛放的重量由`j - weight[i]`到`j`进行状态变化时其实默认是物品放到最后，所以不会出现物品的重复排放（大概感知一下意思罢了，这里确实不很懂）
* 第二种：先遍历背包容量，再遍历物品，本质上是针对每一个背包容量，把每一个物品都放进去，然后剩余的容量再摆放物品，所以背包盛放的重量由`j - weight[i]`到`j`进行状态变化时相当于把每一个物品都放在最后一个的位置了一次，所以会出现逆序的情况（重复的组合），所以求的是排列数（大概理解、理解即可）

**对于咱来说，重要的是把它当作工具去用。就像用Vue取开发一样，不一定知道Vue是怎么实现的。**



# 746.使用最小花费爬楼梯（动态规划）

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

**示例 1：**

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```



~~~js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    const dp = [0, 0]; 
    for(let i = 2; i <= cost.length; i ++) { // 计算dp[i]
        dp.push(Math.min((dp[i - 1] + cost[i - 1]), (dp[i - 2] + cost[i - 2])));
    }
    return dp[dp.length - 1];
};
~~~

## 动态规划五部曲分析

1. 定义dp数组含义：`dp[i]`表示到达第`i`阶楼梯（最小）花费`dp[i]`的体力
2. 递推公式（**问题分解**）：`dp[i] = min( (dp[i - 1] + cost[i - 1]), (dp[i - 2] + cost[i - 2]) )`，我们要跳到楼梯顶部，**使用举例法确定跳几下，比如cost长度为3，即有三阶台阶，`for`循环的遍历变量初始化`i = 2`表示当前已经知道了前两个台阶的答案（这个意义的定义也是随意的，同属于举例法的一部分，举例法就是确定初始化 ➕ i的循环终止条件两个变量的整体），我们需要求出dp[3]，即第四阶台阶的答案，要计算两次，所以`i<=cost.length`——>i=2到i<=3是两次计算**
3. dp数组初始化：因为我们一开始就可以站在第1阶或者第0阶，或者`dp[1] === dp[0] === 0`
4. 确定遍历顺序：这里高阶问题的答案是由低阶确定的，所以自然i从小到大遍历



# 1047.删除字符串中的所有相邻重复项（栈与队列、栈）

给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**

```
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

**这种相邻消除的场景，优先考虑一下栈。**

~~~js
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicates = function(s) {
    const stack = [];
    stack.push(s[0]); // 先放进去一个，为下面的for循环逻辑构造一个初始结构
    if(s.length === 1) return s;
    for(let i = 1; i < s.length; i ++) {
        if(s[i] === stack[stack.length - 1]) {
            stack.pop();
        } else {
            stack.push(s[i]);
        } 
    }
    return stack.join("");
};
~~~





# 1049.最后一块石头的重量 II（0-1背包变式、动态规划、滚动数组）

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```



问题转化：计算出来体积为石头总重量一半的背包最多可以装多少石头，`stones[i]`既为石头体积，也为石头价值，然后就可以用题目中描述的粉碎法去计算最终的结果了

~~~js
/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeightII = function(stones) {
    let sum = stones.reduce((previous, current) => {
        return previous + current;
    }, 0)
    let target = Math.ceil(sum / 2); // 为了防止石头总重为奇数new Array报错所以取整，但是一定要用ceil向上取整（为了保证能出现答案0，背包体积只能大，不能小）
		
  	// 总之这里target具体取值需不要要精确为一半，还是说多点也行，我也没想明白，题目可能测例也有特殊性（比如石头总重都可以整出2），反正这个题目掌握转换为0-1背包的思想就完事了
    const dp = new Array(target + 1).fill(0);

    for(let i = 0; i < stones.length; i ++) {
        for(let j = target; j >= stones[i]; j --) {
            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
        }
    }

    return Math.abs(sum - 2 * dp[target]);
};
~~~





# 剑指 Offer 38. 字符串的排列

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

**示例:**

```
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

## 1.dfs

~~~js
/**
 * @param {string} s
 * @return {string[]}
 */
var permutation = function(str) {
    str = str.split("").sort((a, b) => (a > b ? 1 : -1)).join("");
    let ans = [];
    const dfs = (currentStr, leftStr) => {
        if(leftStr.length === 0) {
            ans.push(currentStr);
            return;
        }
        for(let i = 0;i < leftStr.length;i ++) {
            if(i > 0 && leftStr[i] === leftStr[i - 1]) {
                continue;
            }
            dfs(currentStr + leftStr[i], leftStr.slice(0, i) + leftStr.slice(i + 1));
        }
    }
    dfs("", str);
    return ans;
};
~~~

1. 首先我们接收到一个str，可能是"abcb"这种有重复字母的字符串，我们希望处理这个字符串之后让相同的字符靠着比如"abbc"：

~~~js
str = str.split("").sort((a, b) => (a > b ? 1 : -1)).join("");
~~~

* split分割字符串为字符数组

* sort排序，js中字符虽然不可以做加减运算，但是不同的字符是可以比较大小的，比如"a">"b"会返回一个布尔值，所以sort函数中我们根据a与b的大小关系手动返回一个正数或者负数，就可以实现相同字符的相邻处理

2. 我们dfs函数接收两个参数currentStr和leftStr，dfs的退出条件是leftStr的长度为0，也就是我们字符串已经拼接完成了；
3. dfs中如果leftStr长度不为0，就对leftStr字符串进行逐字符遍历：把leftStr中的每一个字符都拼接到currentStr的最后，递归调用dfs

其实我们就是给currentStr字符串的最后那个位置选择字符，leftStr中的每个字符都可以放到currentStr最后的那个位置，所以我们要遍历leftStr，就相当于把leftStr的每一个字符放到currentStr字符串的最后那个位置，但是有一种情况不能放：leftStr中有重复的字符，自然这个字符不能放到同一位置两次，所以我们第一步处理字符串就是为了这个，如果`leftStr[i] === leftStr[i - 1]`，就说明leftStr[i]这个字符前面已经放到过currentStr字符串的最后那个位置了，所以我们就跳过。

## 同类题目

### 46.数组元素全排列

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

纯简化版（数组元素无重复）

~~~js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const result = [];
    const dfs = (currentArr, leftArr) => {
        if(leftArr.length === 0) {
            result.push(currentArr);
            return ;
        }
        for(let i = 0;i < leftArr.length; i ++) {
            dfs([...currentArr, leftArr[i]], [...leftArr.slice(0, i), ...leftArr.slice(i + 1, leftArr.length)]);
        }
    }
    dfs([], nums);
    return result;
};
~~~



### 47.全排列2

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**示例 2：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

完全同38.字符串排列

~~~js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
    const result = [];
    const dfs = (currentArr, leftArr) => {
        if(leftArr.length === 0) {
            result.push(currentArr);
            return ;
        }
        for(let i = 0;i < leftArr.length; i ++) {
            if(i > 0 && leftArr[i] === leftArr[i - 1]) {
                continue;
            }
            dfs([...currentArr, leftArr[i]], [...leftArr.slice(0, i), ...leftArr.slice(i + 1, leftArr.length)]);
        }
    }
    // 排列数组让相同元素相邻
    nums = nums.sort((a, b) => a - b);
    dfs([], nums);
    return result;
};
~~~





# 0-1背包问题（动态规划）



给定一个背包容量`x`，然后有一些物品，每个物品都有对应的体积和价值，问背包最多可以装多少价值



定义`dp[i][j]`含义：对前`i`个物品（物品集合为前i个），我们背包容量为`j`时我们最多可以装`dp[i][j]`价值。

递推公式：`dp[i][j] = Math.max( dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i] )`，理解：我们计算`dp[i][j]`时理解为动态拓展物品集合的过程（物品集合从前1件，到前i件），基于这个前提理解，对于物品集从前`i - 1`件到前`i`件无非就两种可能：

* 第`i`件物品是构成最优解的一个物品，即`dp[i][j] = dp[i - 1][j - weight[i]] + value[i]`，即对于物品集合为前`i - 1`个变成`i`个时，背包想获取第`i`个物品的价值，就需要给第`i`个物品腾出来它的体积。
* 第`i`件物品不是构成最优解的一个物品，所以物品集合多了它也白扩充，即`dp[i][j] = dp[i - 1][j]`

初始化：由递推公式可知，dp数组`dp[i][j]`依赖于更小的i和j的dp值，所以初始化第一行`dp[i][0]`和`dp[0][j]`即可满足后续推导了，容量为0或者物品集合为0，dp值都为0

遍历顺序：肯定是i和j都从小到大

~~~js
function testWeightBagProblem (weight, value, size) {
    // 定义 dp 数组
    const len = weight.length,
          dp = Array(len).fill().map(() => Array(size + 1).fill(0));

    // 初始化
    for(let j = weight[0]; j <= size; j++) {
        dp[0][j] = value[0];
    }

    // weight 数组的长度len 就是物品个数
    for(let i = 1; i < len; i++) { // 遍历物品
        for(let j = 0; j <= size; j++) { // 遍历背包容量
            if(j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }

    console.table(dp)

    return dp[len - 1][size];
}

function test () {
    console.log(testWeightBagProblem([1, 3, 4, 5], [15, 20, 30, 55], 6));
}

test();
~~~

## 滚动数组——一维dp数组

递推公式：`dp[i][j] = Math.max( dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i] )`，可以看成`dp[i] = Math.max( dp[i - 1][g(j)], dp[i - 1][fn(j)] )`，也就是`dp[i]`是由`dp[i - 1]`推导出来的，所以可以把原来的`i`行dp数组压缩为1行。

还是双重`for`循环，外层遍历物品，内层遍历容量，但是这里需要内层进行倒叙遍历，因为：倒叙计算每一个`dp[j]`的时候其实隐藏信息是我们正在计算第`i`行的`dp[j]`，也就是`dp[i][j]`，用到的`dp[小于j]`其实都是上一行的才对，也就是`dp[i - 1][小于j]`，所以如果我们正序遍历`j`，所造成的后果就是我们计算`dp[j]`的时候用到的前面的`dp[小于j]`其实都是第`i`行的`dp[小于j]`了，递推公式的就错了。

~~~js
function testWeightBagProblem(wight, value, size) {
  const len = wight.length, 
    dp = Array(size + 1).fill(0);
  for(let i = 1; i <= len; i++) {
    for(let j = size; j >= wight[i - 1]; j--) {
      dp[j] = Math.max(dp[j], value[i - 1] + dp[j - wight[i - 1]]);
    }
  }
  return dp[size];
}


function test () {
  console.log(testWeightBagProblem([1, 3, 4, 5], [15, 20, 30, 55], 6));
}

test();
~~~

# 完全背包问题（动态规划）

## **定义：**

0-1背包即每个物品只有一件，完全背包是n种物品，每个物品可以选任意次，求某容量的背包能盛放的最大价值。

## **递推公式：**

二维：`dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])`

滚动数组：`dp[j] = Math.max(dp[j], [j - weight[i]] + value[i]`（同0-1背包的滚动数组递推公式）

## **理解：**

1. 还是以第`i`个物品放不放为线索，如果第`i`个物品不在构成最优解的集合种，也就是`dp[i][j] = dp[i - 1][j]`；
2. 关于`dp[i][j] = dp[i][j - weight[i]] + value[i])`，这里其实是第`i`种物品在构成最优解的集合中，但是因为并不是每种物品只有一个，所以说这里这个递推描述的动态过程是第`i`种物品的第若干个来了，要不要的过程。具体举个例子，`dp[i][j]`为当前的一个最优解，但是如果再来一个第`i`种物品，并且添加这一个第`i`种物品是属于新的最优解的，所以我们就要给这个物品腾出来空间，才能加上它的价值
3. 当初0-1背包中其实也是具体考虑的每一个单独的物品，而不是物品的种类，`dp[i][j] = dp[i - 1][j - weight[i]] + value[i]`其实就是说`dp[i][j]`最优解的情况下，加进来这一个物品（属于`i`类），可能能构成更优解，但正好第`i`类物品只有一个，所以添加这一个物品之前，`dp`的物品状态为`i - 1`；换句话说，对于完全背包，这个物品加进来之前，`dp`的状态还是`i`，这个物品的可能是第`i`类物品的第`n`个

## **滚动数组遍历顺序：**

**说白了这个遍历顺序就是为了保证计算新一行（新`i`）的`dp`数据（本质还是`dp[i][j]`）时他所依赖数据都是正确的（一维数组能正确读取到正确的二维数组的信息）**

之所以0-1背包中更新`dp`数组要倒序遍历，是因为`dp[i][j]`所依靠的是`i(第一维) = i - 1`且`j(第二维) < j`时的`dp`数据，所以倒序遍历更新`dp`才能保证用到的是`i = i - 1`时的数据（还未被更新的上一行数据）

完全背包中需要正序遍历更新`dp`数组，分析一下计算`dp[j]`时（`dp[i][j]`）所需要的两个数据即可，`dp[i - 1][j]`即上一行正上方的数据，所以这个没影响，我们更新`dp[j]`之前自然它本身就代表了`dp[i - 1][j]`；然后`dp[i][j - w[i]] + v[i]`用到的是第`i`行的数据，并且`j(第二维) < j`，所以计算`dp[j]`就需要我们正序遍历，先把第`i`行前面的`dp`计算出来，这样就能保证计算`dp[j]`时读取到正确的数据。

