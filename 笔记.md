# 50.实现 pow(*x*, *n*)，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。

## 1.暴力（原创）：

**暴力（时间超限），核心思路就是for循环n次，每次都乘个x**，最后返回的时候考虑负数幂次的情况。

~~~js
var myPow = function(x, n) {
    if(n === 0) return 1;
    let x_origin = x;
    //通过Math.abs获取n的绝对值
    let absoluteN = Math.abs(n);
    for(let i = 1;i < absoluteN; i++ ) {
        x = x * x_origin;
    }
    return n > 0 ? x : 1 / x;
};
~~~

时间复杂度：`O(n)`

空间复杂度：`0(1)`

## 2.分治法（快速幂）（题解）：

~~~js
var myPow = function(x, n) {
    if(n === 1) return x;
    if(n === 0) return 1;
    if(n < 0) {
        x = 1/x;
        n = Math.abs(n);
    }
    //n为偶数
    if(n % 2 === 0) {
        return myPow(x*x, n/2);
    } else {
        return x*myPow(x*x, Math.floor(n/2));
    }
};
~~~

时间复杂度：`0(logn)`，一个数的n次幂每次函数体执行都变成另一个数的n/2次幂，哪个数的幂这个数多大不重要，因为我们函数结束条件是n决定的，n足够小，函数才结束。所以经过logn次函数体执行，n就变成1了，也就是标志递归结束。然后每次函数体的执行，也就是这个规模缩小的过程，所花费的时间是单位1，执行logn次，所以时间复杂度就是`O(logn)`

空间复杂度：`0(logn)`：递归栈的深度。

方法收集：

* `Math.abs(n)`：获取n的绝对值
* `Math.pow(n,m)`：获取n的m次幂

# 53.给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

## 1.核心思想其实与动态相似（原创）：

从头到尾遍历一遍nums，不断更新最大和

我们需要借助一个beforeSum来记录当前指针位置之前连续项的和。

贪心思想：指针新遍历一个值的时候，**有可能更新最大和**的情况有两种：

* beforeSum大于零，所以我们把当前项加上beforeSum
* beforeSum小于零，当前项自身

这个beforeSum是帮助当前项“冲击“最大和的，所以如果曾经的beforeSum小于零，那么指针新考察过一个项之后，就把beforeSum换成这个刚考察的项即可；如果beforeSum大于零，它就对于”冲击“最大和有帮助，所以我们要保留它并累加上当前项。

~~~js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let currentMax = nums[0];
    let beforeSum = nums[0];
    for(let i = 1;i < nums.length;i ++) {
        if(beforeSum<0) {
            //beforeSum小于零，可能产生的最大和：nums[i]
            if(nums[i] > currentMax) {
                currentMax = nums[i];
            }
            beforeSum = nums[i];
        }else {
            //beforeSum大于零，可以产生的最大和：beforeSum+nums[i]
            beforeSum += nums[i];
            if(beforeSum > currentMax) {
                currentMax = beforeSum;
            }
        }
    }
    return currentMax;
};
~~~

* 时间复杂度：我们只遍历了一次数组，所以`0(n)`

* 空间复杂度：我们只借助了两个变量，使用了常数空间，所以`O(1)`

## 2.动态规划

定义子问题：以`nums`数组中第`i`项结尾的子数组的最大和记为`f(i)`

**`f(i) = max{(f(i-1)+nums[i]), nums[i]}`**

所以遍历nums数组时，就用`nums[i]`表示`f(i)`：如果nums[i-1] > 0，那么f(i) = nums[i] = nums[i-1] + nums[i]

~~~js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let currentMax = nums[0];
    for(let i = 1;i < nums.length;i ++ ) {
        currentMax = Math.max((nums[i] + nums[i - 1]), nums[i], currentMax);
        if(nums[i-1] > 0) {
            nums[i] += nums[i - 1];
        }
    }
    return currentMax;
};
~~~

我感觉和方法一思想完全相同，只是说我们直接利用了nums数组本身来记录方法一中的beforeSum。

时空复杂度也是`O(n)`和`O(1)`